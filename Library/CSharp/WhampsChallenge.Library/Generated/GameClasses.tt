<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Newtonsoft.Json" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ output extension=".cs" #>
// Generated file, so ReSharper-Checks are disabled. 
// ReSharper disable all
<#	var fileName = Path.GetFullPath(Host.ResolvePath("..\\..\\..\\common\\contract.json")); #>
<#  var file = JsonConvert.DeserializeObject<Dictionary<string,JObject>>(File.ReadAllText(fileName)); #>

using System.Threading.Tasks;

using WhampsChallenge.Shared.Communication;
using WhampsChallenge.Shared.Extensions;

<#  foreach (var _kvp in file) { #>
<#		var resultType = (string)_kvp.Value["ResultType"]; #>
namespace WhampsChallenge.Library.<#= _kvp.Key #>.Actions {

	using WhampsChallenge.Library.<#= _kvp.Key #>.Enums;
	using WhampsChallenge.Library.<#= _kvp.Key #>.Types;	

	public class Game {
		private readonly ICommunicator _communicator;

	    public Game(ICommunicator communicator)
	    {
	        _communicator = communicator;
	    }

<#		foreach (var action in ((JObject)_kvp.Value["Actions"]).Properties()) { #>
<#			var parameters = ((JObject)action.Value["Parameters"]).Properties(); #>
		<#= resultType #> <#= action.Name #>(<#= String.Join(", ", parameters.Select(x => $"{x.Value} {x.Name.ToLower()}")) #>) {
			var message = new <#= action.Name #> {
<#			foreach (var parameter in parameters) { #>
				<#= parameter.Name #> = <#= parameter.Name.ToLower() #>,
<#			} #>
			};

			return _communicator.SendAndReceive<<#= resultType #>>(message);
		}

		async Task<<#= resultType #>> <#= action.Name #>Async(<#= String.Join(", ", parameters.Select(x => $"{x.Value} {x.Name.ToLower()}")) #>) {
			var message = new <#= action.Name #> {
<#			foreach (var parameter in parameters) { #>
				<#= parameter.Name #> = <#= parameter.Name.ToLower() #>,
<#			} #>
			};

			return await _communicator.SendAndReceiveAsync<<#= resultType #>>(message);
		}

<#      } #>
	}
}

<# } #>